import { randomBytes } from '@exodus/crypto/randomBytes'
import { describe, test } from '@exodus/test/node'
import { readFileSync } from 'fs'
import { join } from 'path'
import { metadata } from 'secure-container' // eslint-disable-line import/no-extraneous-dependencies
import { decryptCompressed as dec, encryptCompressed as enc } from 'secure-container/compressed' // eslint-disable-line import/no-extraneous-dependencies

// This file was generated by seco-keyval tests
const file = readFileSync(join(import.meta.dirname, 'fixtures/seco-keyval.test.seco'))
const passphrase = Buffer.from('please let me in')

const isPlainObject = (x) =>
  x && typeof x === 'object' && [null, Object.prototype].includes(Object.getPrototypeOf(x))

export const testKeyvalContents = async (t, all, { salt, blobKey }) => {
  t.ok(isPlainObject(all), 'result should be a plain object')

  t.ok(Buffer.isBuffer(all.data), 'data should be a buffer')
  const expectedData = Buffer.from('{"person1":{"name":"JP"},"person2":{"name":"Daniel"}}')
  t.ok(Buffer.compare(all.data, expectedData) === 0, 'data should match expected')

  t.ok(isPlainObject(all.metadata), 'metadata should be a plain object')
  const metadataCopy = metadata.decode(metadata.encode(all.metadata))
  t.deepEqual(all.metadata, metadataCopy, 'metadata should be re-encodable')

  t.equal(all.metadata.cipher, 'aes-256-gcm', 'file cipher is aes-256-gcm')

  t.ok(isPlainObject(all.metadata.scrypt), 'metadata scrypt args should be a plain object')
  t.ok(Buffer.isBuffer(all.metadata.scrypt.salt), 'salt should be a buffer')
  t.ok(all.metadata.scrypt.salt.length === 32, 'salt should be 32 bytes')
  const expectedScrypt = { salt, n: 16_384, r: 8, p: 1 }
  t.deepEqual(all.metadata.scrypt, expectedScrypt, 'scrypt args should match expected')

  t.ok(Buffer.isBuffer(all.blobKey) && all.blobKey.length === 32, 'file blobKey is 32-byte buffer')
  t.ok(Buffer.compare(all.blobKey, blobKey) === 0, 'blob key should match expected')

  t.ok(isPlainObject(all.header), 'header should be a plain object')
  const expectedHeader = {
    magic: Buffer.from('SECO'),
    version: 0,
    reserved: 0,
    versionTag: 'seco-v0-scrypt-aes',
    appName: 'test',
    appVersion: '1.0.0',
  }
  t.deepEqual(all.header, expectedHeader, 'header should match expected')
}

describe('data produced by seco-keyval', { concurrency: true }, () => {
  test('can decrypt', async (context) => {
    context.plan(16)
    const { assert: t } = context

    const pass2 = randomBytes(16)

    // default is expandTo32k: false, it will throw
    await t.rejects(() => dec(file, passphrase), 'expandTo32k')
    await t.rejects(() => dec(file, pass2, { expandTo32k: true }), 'wrong password')

    const all = await dec(file, passphrase, { expandTo32k: true })

    await testKeyvalContents(t, all, {
      salt: Buffer.from('n0yMfBy8MDYSqqAzQWa9vOICmKyYqSAHhp6KfVOj07Q=', 'base64'),
      blobKey: Buffer.from('n9cCx1OF9PMi7Fz6w8LnaxwLzHOIJmsBI6A2L8RmGJs=', 'base64'),
    })
  })

  test('can decrypt-encrypt-decrypt using the same blobKey', async (context) => {
    context.plan(18)
    const t = context.assert

    const a = await dec(file, passphrase, { expandTo32k: true })
    const header = { appName: 'test', appVersion: '1.0.0' }
    const { metadata, blobKey } = a // will reuse

    // Re-encode with expandTo32k = true

    const c0 = await enc(a.data, { header, metadata, blobKey, expandTo32k: true })
    const c1 = await enc(a.data, { header, metadata, blobKey, expandTo32k: true })
    const d0 = await dec(c0.encryptedData, passphrase, { expandTo32k: true })
    const d1 = await dec(c1.encryptedData, passphrase, { expandTo32k: true })

    await t.deepEqual(c0.metadata, metadata)
    await t.deepEqual(c0.blobKey, blobKey)
    await t.deepEqual(c1.metadata, metadata)
    await t.deepEqual(c1.blobKey, blobKey)
    await t.deepEqual(a.data, d0.data)
    await t.deepEqual(a.data, d1.data)

    // should be different because of expandTo32k _and_ random iv
    await t.notDeepEqual(file, c0.encryptedData)
    await t.notDeepEqual(file, c1.encryptedData)
    await t.notDeepEqual(c0.encryptedData, c1.encryptedData)
    await t.notDeepEqual(d0, d1) // different authTag and iv

    // Re-encode with expandTo32k = false

    const f0 = await enc(a.data, { header, metadata, blobKey })
    const f1 = await enc(a.data, { header, metadata, blobKey })
    const g0 = await dec(f0.encryptedData, passphrase)
    const g1 = await dec(f1.encryptedData, passphrase)

    await t.deepEqual(f0.metadata, metadata)
    await t.deepEqual(f0.blobKey, blobKey)
    await t.deepEqual(f1.metadata, metadata)
    await t.deepEqual(f1.blobKey, blobKey)
    await t.deepEqual(a.data, g0.data)
    await t.deepEqual(a.data, g1.data)

    // should be different because of random iv
    await t.notDeepEqual(f0.encryptedData, f1.encryptedData)
    await t.notDeepEqual(g0, g1) // different authTag and iv
  })

  test('can decrypt-encrypt-decrypt, expandTo32k = true', async (context) => {
    context.plan(17)
    const t = context.assert

    const pass2 = randomBytes(16)

    const original = await dec(file, passphrase, { expandTo32k: true })
    const header = { appName: 'test', appVersion: '1.0.0' }
    const c = await enc(original.data, { header, passphrase: pass2, expandTo32k: true })

    // default is expandTo32k: false, it will throw
    await t.rejects(() => dec(c.encryptedData, pass2), 'expandTo32k')
    await t.rejects(() => dec(c.encryptedData, passphrase, { expandTo32k: true }), 'wrong password')

    const all = await dec(c.encryptedData, pass2, { expandTo32k: true })
    await t.deepEqual(all.metadata, c.metadata)
    await testKeyvalContents(t, all, { salt: c.metadata.scrypt.salt, blobKey: c.blobKey })
  })

  test('can decrypt-encrypt-decrypt, expandTo32k = false', async (context) => {
    context.plan(17)
    const t = context.assert

    const pass2 = randomBytes(16)

    const original = await dec(file, passphrase, { expandTo32k: true })
    const header = { appName: 'test', appVersion: '1.0.0' }
    const c = await enc(original.data, { header, passphrase: pass2 })

    // default for encrypt is expandTo32k: false, decoding with true will throw
    await t.rejects(() => dec(c.encryptedData, pass2, { expandTo32k: true }), 'expandTo32k')
    await t.rejects(() => dec(c.encryptedData, passphrase), 'wrong password')

    const all = await dec(c.encryptedData, pass2)
    await t.deepEqual(all.metadata, c.metadata)
    await testKeyvalContents(t, all, { salt: c.metadata.scrypt.salt, blobKey: c.blobKey })
  })
})

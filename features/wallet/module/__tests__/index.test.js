import keychainDefinition from '@exodus/keychain/module/index.js'
import { getSeedId } from '@exodus/key-utils'
import KeyIdentifier from '@exodus/key-identifier'
import createInMemoryStorage from '@exodus/storage-memory'
import { mnemonicToSeed, validateMnemonic } from 'bip39'
import walletDefinition from '../index.js'
import createSeedStorage from './seed-storage.js'
import { NamedError } from '../utils.js'
import primarySeedIdAtomDefinition from '../../atoms/primary-seed-id.js'
import seedMetadataAtomDefinition from '../../atoms/seed-metadata.js'
import BJSON from 'buffer-json'
import * as bip39 from 'bip39'

const { factory: createWallet } = walletDefinition

const mnemonic = 'cousin access oak tragic entire dynamic marine expand govern enjoy honey tissue'
const otherMnemonic =
  'menu memory fury language physical wonder dog valid smart edge decrease worth'

const seed = mnemonicToSeed(mnemonic)
const otherSeed = mnemonicToSeed(otherMnemonic)

const createKeychain = () => keychainDefinition.factory({})
const createUnencryptedSeedStorage = () =>
  createInMemoryStorage({
    transformOnWrite: BJSON.stringify,
    transformOnRead: BJSON.parse,
    skipValueValidation: true,
  })

describe.each([{ useAutoGeneratedPassword: true }, { useAutoGeneratedPassword: false }])(
  'wallet with useAutoGeneratedPassword:$useAutoGeneratedPassword',
  ({ useAutoGeneratedPassword }) => {
    let now

    let keychain
    let primarySeedIdAtom
    let wallet
    let walletOpts
    let storage
    let seedStorage
    let seedMetadataAtom

    const maxExtraSeeds = 2

    beforeEach(() => {
      now = Date.now()
      keychain = createKeychain()

      storage = createInMemoryStorage()
      seedStorage = createSeedStorage()

      primarySeedIdAtom = primarySeedIdAtomDefinition.factory()
      seedMetadataAtom = seedMetadataAtomDefinition.factory({ storage })

      walletOpts = {
        clock: { now: () => now },
        unsafeStorage: storage,
        seedStorage,
        keychain,
        primarySeedIdAtom,
        seedMetadataAtom,
        logger: { debug: jest.fn() },
        config: { maxExtraSeeds, useAutoGeneratedPassword, validMnemonicLengths: [12] },
      }

      wallet = createWallet(walletOpts)
    })

    it('wallet exists() is false for a new wallet', async () => {
      expect(await wallet.exists()).toEqual(false)
    })

    it('wallet is still locked after create()', async () => {
      await wallet.create()
      await expect(wallet.isLocked()).resolves.toEqual(true)
    })

    it('wallet starts out locked', async () => {
      await expect(wallet.isLocked()).resolves.toEqual(true)
    })

    it('limits "create" concurrency to 1', async () => {
      const walletSeedIds = []
      let firstSeedId
      let secondSeedId

      jest.spyOn(keychain, 'clear').mockImplementationOnce(() => {
        return new Promise((resolve) => {
          setTimeout(resolve, 100)
        })
      })

      const firstPromise = wallet.create()
      const secondPromise = wallet.create()
      firstPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        firstSeedId = seedId
      })
      secondPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        secondSeedId = seedId
      })

      await Promise.all([firstPromise, secondPromise])

      expect(walletSeedIds).toEqual([firstSeedId, secondSeedId])
    })

    it('limits "import" concurrency to 1', async () => {
      const walletSeedIds = []
      let firstSeedId
      let secondSeedId

      jest.spyOn(keychain, 'clear').mockImplementationOnce(() => {
        return new Promise((resolve) => {
          setTimeout(resolve, 100)
        })
      })

      const firstPromise = wallet.import({ mnemonic })
      const secondPromise = wallet.import({ mnemonic: otherMnemonic })
      firstPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        firstSeedId = seedId
      })
      secondPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        secondSeedId = seedId
      })

      await Promise.all([firstPromise, secondPromise])

      expect(walletSeedIds).toEqual([firstSeedId, secondSeedId])
    })

    it('constructor throws when maxExtraSeeds not an integer', () => {
      expect(() => createWallet({ ...walletOpts, config: { maxExtraSeeds: 'hallo' } })).toThrow(
        'maxExtraSeeds has to be an integer'
      )
    })

    it('isLocked changes on lock/unlock', async () => {
      await wallet.create()

      await wallet.lock()
      await expect(wallet.isLocked()).resolves.toEqual(true)
      await wallet.unlock()
      await expect(wallet.isLocked()).resolves.toEqual(false)
    })

    it('unlock returns primarySeedId', async () => {
      await wallet.import({ mnemonic })
      const { primarySeedId } = await wallet.unlock()

      expect(getSeedId(seed)).toBe(primarySeedId)
    })

    it('wallet.lock() locks keychain', async () => {
      const keychain = createKeychain()
      keychain.removeAllSeeds = jest.fn(keychain.removeAllSeeds)
      const wallet = createWallet({ ...walletOpts, keychain })
      await wallet.create()
      expect(keychain.removeAllSeeds).not.toHaveBeenCalled()
      await wallet.lock()
      expect(keychain.removeAllSeeds).toHaveBeenCalled()
    })

    it('wallet.unlock() unlocks without providing a passphrase', async () => {
      await wallet.create()
      await expect(wallet.unlock()).resolves.not.toThrow()
    })

    it('wallet.getMnemonic() to work without providing a passphrase', async () => {
      await wallet.create()

      const mnemonic = await wallet.getMnemonic()
      expect(() => validateMnemonic(mnemonic)).not.toThrow()
    })

    // various create() opts
    describe.each([{}, { mnemonic }, { mnemonic, passphrase: 'abracadabra' }])(
      'wallet.create(%s)',
      (createOpts) => {
        it('wallet.exists() is true after wallet.create() ', async () => {
          await wallet.create(createOpts)
          expect(await wallet.exists()).toEqual(true)
        })

        const passphraseNotPassed = createOpts?.passphrase === undefined
        const passphraseStatus = passphraseNotPassed ? 'not-passed' : 'passed'

        it(`hasPassphraseSet() is ${passphraseNotPassed} if password was ${passphraseStatus}`, async () => {
          expect(await wallet.hasPassphraseSet()).toEqual(false)

          await wallet.create(createOpts)

          expect(await wallet.hasPassphraseSet()).toEqual(!passphraseNotPassed)
        })

        it(`hasPassphraseSet() falls back to getGeneratedPassphrase when hasUserSetPassphrase missing`, async () => {
          expect(await wallet.hasPassphraseSet()).toEqual(false)

          await wallet.create(createOpts)
          await seedStorage.namespace('wallet').delete('hasUserSetPassphrase')

          if (useAutoGeneratedPassword)
            expect(await wallet.hasPassphraseSet()).toEqual(!passphraseNotPassed)
          else expect(await wallet.hasPassphraseSet()).toEqual(true)
        })
      }
    )

    const importScenarios = [
      { mnemonic },
      { mnemonic, passphrase: 'abracadabra' },
      { mnemonic, locked: true },
      { mnemonic, locked: true, passphrase: 'abracadabra' },
    ]

    describe.each(importScenarios)(
      'wallet.import($mnemonic)',
      ({ mnemonic, passphrase, locked }) => {
        it('wallet is valid after wallet.import() ', async () => {
          const seedId = getSeedId(mnemonicToSeed(mnemonic))

          if (locked) await wallet.lock()
          await wallet.import({ mnemonic, passphrase })

          expect(await wallet.exists()).toEqual(true)
          expect(await wallet.getMnemonic({ passphrase })).toEqual(mnemonic)

          const metadata = await seedMetadataAtom.get()
          expect(metadata[seedId].dateCreated).toBe(now)
        })
      }
    )

    it('lets you change the passphrase', async () => {
      const currentPassphrase = 'abc'
      const newPassphrase = '123'
      await wallet.create({ passphrase: currentPassphrase })
      await wallet.changePassphrase({ currentPassphrase, newPassphrase })
      const wallet1 = createWallet(walletOpts)
      await expect(wallet1.unlock({ passphrase: currentPassphrase })).rejects.toThrow(
        /wrong password/i
      )
      await expect(wallet1.unlock({ passphrase: newPassphrase })).resolves.not.toThrow()
    })

    describe('import', () => {
      it.each([
        [
          'invalid length',
          'cousin access oak tragic entire dynamic marine expand govern enjoy honey',
          new NamedError({ name: 'UnexpectedWordCount' }),
        ],
        [
          'invalid words',
          'cousin rudolf peter jÃ¼rgen entire dynamic marine expand govern enjoy honey tissue',
          new NamedError({ name: 'InvalidPhrase' }),
        ],
        ['invalid type', mnemonic.split(' '), /the secret phrase provided is not a string/i],
      ])('should throw when mnemonic has %s', async (_, mnemonic, error) => {
        await expect(wallet.import({ mnemonic })).rejects.toThrow(error)
      })

      it('supports more mnemonic lengths when configured to', async () => {
        const mnemonic = await bip39.generateMnemonic(256) // 256 = 24 words

        const wallet = createWallet({
          ...walletOpts,
          config: { maxExtraSeeds, useAutoGeneratedPassword, validMnemonicLengths: [12, 24] },
        })

        await expect(wallet.import({ mnemonic })).resolves.not.toThrow()
      })
    })

    describe('multiple seeds', () => {
      const ethereumKeyId = new KeyIdentifier({
        asset: 'ethereum',
        derivationAlgorithm: 'BIP32',
        derivationPath: `m/44'/60'/0'/0/0`,
      })

      describe('addSeed', () => {
        it('stores keys in keychain', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
            compatibilityMode: 'phantom',
          })

          const { publicKey, privateKey } = await keychain.exportKey({
            seedId,
            keyId: ethereumKeyId,
            exportPrivate: true,
          })

          expect(publicKey).toEqual(
            Buffer.from('020c8da08ca8ef147ea64323e539d791013ff0db4ae9d31c93e29482189af70de5', 'hex')
          )

          expect(privateKey).toEqual(
            Buffer.from('bb42809079e6564ec7e45af4d6a8fb8c5edc9373d8585b86f62f46ec7aa41729', 'hex')
          )
        })
      })

      it('sets seeds metadata', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({
          mnemonic: otherMnemonic,
          label: 'Metamask Savings',
          compatibilityMode: 'phantom',
        })

        await expect(seedMetadataAtom.get()).resolves.toMatchObject({
          [seedId]: {
            label: 'Metamask Savings',
            dateCreated: now,
          },
        })
      })

      it('stores data in wallet storage', async () => {
        const seedStorage = createUnencryptedSeedStorage()
        const wallet = createWallet({ ...walletOpts, seedStorage })

        await wallet.create()
        await wallet.unlock()

        await wallet.addSeed({
          mnemonic: otherMnemonic,
          label: 'Metamask Savings',
          compatibilityMode: 'phantom',
        })

        const extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
        expect(extraSeeds.length).toBe(1)

        const [seed] = extraSeeds
        expect(seed).toMatchObject({
          mnemonic: otherMnemonic,
          compatibilityMode: 'phantom',
        })

        expect(Buffer.isBuffer(seed.seed)).toBe(true)
        expect(seed.dateCreated).toBe(now)
      })

      it('removes a single seed', async () => {
        const seedStorage = createUnencryptedSeedStorage()
        const wallet = createWallet({ ...walletOpts, seedStorage })
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic, label: 'Metamask Savings' })
        const otherSeedId = await wallet.addSeed({ mnemonic: 'menu '.repeat(12).trim() })
        let extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
        expect(extraSeeds.length).toBe(2)

        const keys = await Promise.all(
          [seedId, otherSeedId].map((id) => {
            return keychain.exportKey({
              seedId: id,
              keyId: ethereumKeyId,
            })
          })
        )

        keys.forEach((key) => {
          expect(key).toBeDefined()
        })

        await wallet.removeSeed(seedId)
        extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
        expect(extraSeeds.length).toBe(1)

        extraSeeds.forEach((seed) => {
          expect(seed && typeof seed === 'object').toBe(true)
          expect(seed.mnemonic).toMatch(/^(\b\w+\b\s+){11}\b\w+\b$/) // 12 words
          expect(typeof seed.dateCreated).toBe('number')
          expect(Buffer.isBuffer(seed.seed)).toBe(true)
        })

        await expect(() =>
          keychain.exportKey({
            seedId,
            keyId: ethereumKeyId,
          })
        ).rejects.toThrow(`seed "${seedId}" is not initialized`)

        await wallet.lock()
        await wallet.unlock()

        await expect(() =>
          keychain.exportKey({
            seedId,
            keyId: ethereumKeyId,
          })
        ).rejects.toThrow(`seed "${seedId}" is not initialized`)

        extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
        expect(extraSeeds.length).toBe(1)
      })

      it('does not throw when removing a single seed (encrypted seed storage)', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic, label: 'Metamask Savings' })
        await expect(wallet.removeSeed(seedId)).resolves.not.toThrow()
      })

      it('removes multiple seeds at once', async () => {
        const seedStorage = createUnencryptedSeedStorage()
        const wallet = createWallet({
          ...walletOpts,
          seedStorage,
          config: { maxExtraSeeds: 5, useAutoGeneratedPassword, validMnemonicLengths: [12] },
        })
        await wallet.create()
        await wallet.unlock()

        const seedId01 = await wallet.addSeed({ mnemonic: otherMnemonic })
        const seedId02 = await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })
        const seedId03 = await wallet.addSeed({ mnemonic: 'abandon '.repeat(12).trim() })

        const keys = await Promise.all(
          [seedId01, seedId02, seedId03].map((id) => {
            return keychain.exportKey({
              seedId: id,
              keyId: ethereumKeyId,
              exportPrivate: true,
            })
          })
        )

        keys.forEach((key) => {
          expect(key).toBeDefined()
        })

        let extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
        expect(extraSeeds.length).toBe(3)

        const removedSeedIds = [seedId01, seedId02]
        await wallet.removeManySeeds(removedSeedIds)
        extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
        expect(extraSeeds.length).toBe(1)

        extraSeeds.forEach((seed) => {
          expect(seed && typeof seed === 'object').toBe(true)
          expect(seed.mnemonic).toMatch(/^(\b\w+\b\s+){11}\b\w+\b$/) // 12 words
          expect(typeof seed.dateCreated).toBe('number')
          expect(Buffer.isBuffer(seed.seed)).toBe(true)
        })

        await Promise.allSettled(
          removedSeedIds.map(async (seedId) => {
            await expect(() =>
              keychain.exportKey({
                seedId,
                keyId: ethereumKeyId,
              })
            ).rejects.toThrow(`seed "${seedId}" is not initialized`)
          })
        )

        await wallet.create()
        await wallet.unlock()

        await Promise.allSettled(
          removedSeedIds.map(async (seedId) => {
            await expect(() =>
              keychain.exportKey({
                seedId,
                keyId: ethereumKeyId,
              })
            ).rejects.toThrow(`seed "${seedId}" is not initialized`)
          })
        )

        const remainingSeed = await keychain.exportKey({
          seedId: seedId03,
          keyId: ethereumKeyId,
          exportPrivate: true,
        })

        expect(remainingSeed).toEqual(keys[2])
      })

      it('does not throw when removing multiple seeds at once (encrypted seed storage)', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId01 = await wallet.addSeed({ mnemonic: otherMnemonic })
        const seedId02 = await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })

        await expect(wallet.removeManySeeds([seedId01, seedId02])).resolves.not.toThrow()
      })

      it('fetches extraSeedIds', async () => {
        await wallet.create()
        await wallet.unlock()

        await expect(wallet.getExtraSeedIds()).resolves.toEqual([])

        const seedId01 = await wallet.addSeed({ mnemonic: otherMnemonic })
        const seedId02 = await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })

        await expect(wallet.getExtraSeedIds()).resolves.toEqual([seedId01, seedId02])
      })

      it('removes seeds metadata', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic, label: 'Metamask Savings' })

        await wallet.removeSeed(seedId)
        const metadata = await seedMetadataAtom.get()
        expect(metadata).not.toHaveProperty(seedId)
      })

      it('does not remove primary seed', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await primarySeedIdAtom.get()
        await expect(wallet.removeSeed(seedId)).rejects.toThrow('Cannot remove primary seed')
      })

      it('does not allow removing seeds with wallet locked', async () => {
        await wallet.create()
        await expect(wallet.removeSeed('test')).rejects.toThrow('locked')
      })

      it('can update seed metadata', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic, label: 'Metamask Savings' })

        const dateCreated = now
        now = Date.now()

        await wallet.updateSeed({ seedId, label: "Bruce Wayne's Savings" })

        await expect(seedMetadataAtom.get()).resolves.toMatchObject({
          [seedId]: {
            label: "Bruce Wayne's Savings",
            dateCreated,
            dateUpdated: now,
          },
        })
      })

      it('updating seed does not allow overriding dateCreated', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic, label: 'Metamask Savings' })

        await wallet.updateSeed({
          seedId,
          label: 'ABC',
          dateCreated: new Date(2022, 0, 20).getTime(),
        })

        await expect(seedMetadataAtom.get()).resolves.toMatchObject({
          [seedId]: { label: 'ABC', dateCreated: now },
        })
      })

      it('extra seeds survive lock + unlock', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })
        await wallet.lock()
        await wallet.unlock()

        const { publicKey } = await keychain.exportKey({
          seedId,
          keyId: ethereumKeyId,
        })

        expect(publicKey).toEqual(
          Buffer.from('020c8da08ca8ef147ea64323e539d791013ff0db4ae9d31c93e29482189af70de5', 'hex')
        )
      })

      it('getMnemonic() can get extra seeds', async () => {
        await wallet.create()
        await wallet.unlock()

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })

        const mnemonic = await wallet.getMnemonic({ seedId })
        expect(() => validateMnemonic(mnemonic)).not.toThrow()
        expect(otherMnemonic === mnemonic).toBeTruthy()
      })

      it('getMnemonic() throws for extra seeds if passphrase incorrect', async () => {
        const passphrase = '123456'
        await wallet.create({ passphrase })
        await wallet.unlock({ passphrase })

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })

        await expect(() => wallet.getMnemonic({ seedId })).rejects.toThrow(
          'Wrong password. Try again.'
        )
      })

      it('getMnemonic() can get extra seeds if passphrase correct', async () => {
        const passphrase = '123456'
        await wallet.create({ passphrase })
        await wallet.unlock({ passphrase })

        const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })

        const mnemonic = await wallet.getMnemonic({ seedId, passphrase })
        expect(() => validateMnemonic(mnemonic)).not.toThrow()
        expect(otherMnemonic === mnemonic).toBeTruthy()
      })

      it('getMnemonic() throws for extra seeds if seedId not found', async () => {
        await wallet.create()
        await wallet.unlock()

        await wallet.addSeed({ mnemonic: otherMnemonic })

        await expect(() => wallet.getMnemonic({ seedId: 'random' })).rejects.toThrow(
          'No seed matches seedId.'
        )
      })
    })

    describe('primarySeedIdAtom', () => {
      const seedId = getSeedId(mnemonicToSeed(mnemonic))
      it('sets primarySeedIdAtom on unlock', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await expect(primarySeedIdAtom.get()).resolves.toEqual(seedId)
      })

      it('primarySeedIdAtom.get works while locked', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await wallet.lock()
        await expect(primarySeedIdAtom.get()).resolves.toEqual(seedId)
      })
    })

    describe('addSeed', () => {
      it('throws if wallet is locked', async () => {
        await wallet.import({ mnemonic })
        await wallet.lock()
        await expect(wallet.addSeed({ mnemonic: otherMnemonic })).rejects.toThrow(/locked/)
      })

      it('throws is primary seed is re-added as extra seed', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await expect(wallet.addSeed({ mnemonic })).rejects.toThrow(/already present/)
      })

      it('allows to add an extra seed', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        keychain.addSeed = jest.fn(keychain.addSeed)
        await expect(wallet.addSeed({ mnemonic: otherMnemonic })).resolves.not.toThrow()
        expect(keychain.addSeed).toHaveBeenCalledWith(otherSeed)
      })

      it('throws if same extra seed added twice', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await expect(wallet.addSeed({ mnemonic: otherMnemonic })).resolves.not.toThrow()
        await expect(wallet.addSeed({ mnemonic: otherMnemonic })).rejects.toThrow(/already present/)
      })

      it('loads extra seed on unlock', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await wallet.addSeed({ mnemonic: otherMnemonic })
        await wallet.lock()
        keychain.addSeed = jest.fn(keychain.addSeed)
        await wallet.unlock()
        expect(keychain.addSeed).toHaveBeenCalledWith(seed)
        expect(keychain.addSeed).toHaveBeenCalledWith(otherSeed)
      })

      it('clears extra seeds on clear()', async () => {
        seedMetadataAtom.set = jest.fn(seedMetadataAtom.set)

        await wallet.import({ mnemonic })
        await wallet.unlock()
        await wallet.addSeed({ mnemonic: otherMnemonic })
        await wallet.clear()
        await wallet.import({ mnemonic })
        keychain.addSeed = jest.fn(keychain.addSeed)
        await wallet.unlock()
        expect(keychain.addSeed).toHaveBeenCalledWith(seed)
        expect(keychain.addSeed).not.toHaveBeenCalledWith(otherSeed)
        expect(seedMetadataAtom.set).toHaveBeenCalledWith(undefined)
      })

      it('allows adding seeds up to the configured cap (maxExtraSeeds)', async () => {
        const seedStorage = createUnencryptedSeedStorage()
        const wallet = createWallet({ ...walletOpts, seedStorage })
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await wallet.addSeed({ mnemonic: otherMnemonic })
        await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })

        const extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
        expect(extraSeeds.length).toBe(2)
      })

      it('caps max seeds at configured value', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await wallet.addSeed({ mnemonic: otherMnemonic })
        await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })
        await expect(wallet.addSeed({ mnemonic: 'abandon '.repeat(12).trim() })).rejects.toThrow(
          /Maximum/
        )
      })
    })
  }
)

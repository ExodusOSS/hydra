import { generateMnemonic, mnemonicIsInvalid, mnemonicToSeed } from '@exodus/bip39'
import KeyIdentifier from '@exodus/key-identifier'
import { getSeedId } from '@exodus/key-utils'
import keychainDefinition from '@exodus/keychain/module/index.js'
import createInMemoryStorage from '@exodus/storage-memory'
import BJSON from 'buffer-json'

import primarySeedIdAtomDefinition from '../../atoms/primary-seed-id.js'
import seedMetadataAtomDefinition from '../../atoms/seed-metadata.js'
import walletDefinition from '../index.js'
import { NamedError } from '../utils.js'
import createSeedStorage from './seed-storage.js'

const { factory: createWallet } = walletDefinition

const mnemonic = 'cousin access oak tragic entire dynamic marine expand govern enjoy honey tissue'
const otherMnemonic =
  'menu memory fury language physical wonder dog valid smart edge decrease worth'

const seed = await mnemonicToSeed({ mnemonic, format: 'buffer' })
const otherSeed = await mnemonicToSeed({ mnemonic: otherMnemonic, format: 'buffer' })

const createKeychain = () => keychainDefinition.factory({})
const createUnencryptedSeedStorage = () =>
  createInMemoryStorage({
    transformOnWrite: BJSON.stringify,
    transformOnRead: BJSON.parse,
    skipValueValidation: true,
  })

describe.each([
  { usePassword: false, useAutoGeneratedPassword: false, maxExtraSeeds: 0 },
  { usePassword: true, useAutoGeneratedPassword: false, maxExtraSeeds: 2 },
  { usePassword: true, useAutoGeneratedPassword: true, maxExtraSeeds: 0 },
  { usePassword: true, useAutoGeneratedPassword: true, maxExtraSeeds: 2 },
])(
  'wallet with usePassword:$usePassword and useAutoGeneratedPassword:$useAutoGeneratedPassword',
  ({ usePassword, useAutoGeneratedPassword, maxExtraSeeds }) => {
    let now

    let keychain
    let primarySeedIdAtom
    let wallet
    let walletOpts
    let storage
    let seedStorage
    let seedMetadataAtom

    beforeEach(() => {
      now = Date.now()
      keychain = createKeychain()

      storage = createInMemoryStorage()
      seedStorage = createSeedStorage()

      primarySeedIdAtom = primarySeedIdAtomDefinition.factory()
      seedMetadataAtom = seedMetadataAtomDefinition.factory({ storage })

      walletOpts = {
        clock: { now: () => now },
        unsafeStorage: storage,
        seedStorage,
        keychain,
        primarySeedIdAtom,
        seedMetadataAtom,
        logger: { debug: jest.fn() },
        config: {
          maxExtraSeeds,
          usePassword,
          useAutoGeneratedPassword,
          validMnemonicLengths: [12],
        },
      }

      wallet = createWallet(walletOpts)
    })

    it('wallet exists() is false for a new wallet', async () => {
      expect(await wallet.exists()).toEqual(false)
    })

    it('wallet is still locked after create()', async () => {
      await wallet.create()
      await expect(wallet.isLocked()).resolves.toEqual(true)
    })

    it('wallet starts out locked', async () => {
      await expect(wallet.isLocked()).resolves.toEqual(true)
    })

    it('limits "create" concurrency to 1', async () => {
      const walletSeedIds = []
      let firstSeedId
      let secondSeedId

      const firstPromise = wallet.create()
      const secondPromise = wallet.create()
      firstPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        firstSeedId = seedId
      })
      secondPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        secondSeedId = seedId
      })

      await Promise.all([firstPromise, secondPromise])

      expect(walletSeedIds).toEqual([firstSeedId, secondSeedId])
    })

    it('limits "import" concurrency to 1', async () => {
      const walletSeedIds = []
      let firstSeedId
      let secondSeedId

      const firstPromise = wallet.import({ mnemonic })
      const secondPromise = wallet.import({ mnemonic: otherMnemonic })
      firstPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        firstSeedId = seedId
      })
      secondPromise.then((seedId) => {
        walletSeedIds.push(seedId)
        secondSeedId = seedId
      })

      await Promise.all([firstPromise, secondPromise])

      expect(walletSeedIds).toEqual([firstSeedId, secondSeedId])
    })

    it('constructor throws when maxExtraSeeds not an integer', () => {
      expect(() => createWallet({ ...walletOpts, config: { maxExtraSeeds: 'hallo' } })).toThrow(
        'maxExtraSeeds has to be an integer'
      )
    })

    it('isLocked changes on lock/unlock', async () => {
      await wallet.create()

      await wallet.lock()
      await expect(wallet.isLocked()).resolves.toEqual(true)
      await wallet.unlock()
      await expect(wallet.isLocked()).resolves.toEqual(false)
    })

    it('unlock returns primarySeedId', async () => {
      await wallet.import({ mnemonic })
      const { primarySeedId } = await wallet.unlock()

      expect(await getSeedId(seed)).toBe(primarySeedId)
    })

    it('wallet.lock() locks keychain', async () => {
      const keychain = createKeychain()
      keychain.removeAllSeeds = jest.fn(keychain.removeAllSeeds)
      const wallet = createWallet({ ...walletOpts, keychain })
      await wallet.create()
      expect(keychain.removeAllSeeds).not.toHaveBeenCalled()
      await wallet.lock()
      expect(keychain.removeAllSeeds).toHaveBeenCalled()
    })

    it('wallet.unlock() unlocks without providing a passphrase', async () => {
      await wallet.create()
      await expect(wallet.unlock()).resolves.not.toThrow()
    })

    it('wallet.getMnemonic() to work without providing a passphrase', async () => {
      await wallet.create()

      const mnemonic = await wallet.getMnemonic()
      await expect(mnemonicIsInvalid({ mnemonic })).resolves.toBe(false)
    })

    // various create() opts
    describe.each([{}, { mnemonic }, { mnemonic, passphrase: 'abracadabra' }])(
      'wallet.create(%s)',
      (createOpts) => {
        it('wallet.exists() is true after wallet.create() ', async () => {
          await wallet.create(createOpts)
          expect(await wallet.exists()).toEqual(true)
        })

        const passphraseNotPassed = createOpts?.passphrase === undefined
        const passphraseStatus = passphraseNotPassed ? 'not-passed' : 'passed'

        it(`hasPassphraseSet() is ${passphraseNotPassed} if password was ${passphraseStatus}`, async () => {
          expect(await wallet.hasPassphraseSet()).toEqual(false)

          await wallet.create(createOpts)

          if (usePassword) {
            expect(await wallet.hasPassphraseSet()).toEqual(!passphraseNotPassed)
          } else {
            expect(await wallet.hasPassphraseSet()).toEqual(false)
          }
        })

        it(`hasPassphraseSet() falls back to getGeneratedPassphrase when hasUserSetPassphrase missing`, async () => {
          expect(await wallet.hasPassphraseSet()).toEqual(false)

          await wallet.create(createOpts)
          await seedStorage.namespace('wallet').delete('hasUserSetPassphrase')

          if (usePassword) {
            if (useAutoGeneratedPassword) {
              expect(await wallet.hasPassphraseSet()).toEqual(!passphraseNotPassed)
            } else expect(await wallet.hasPassphraseSet()).toEqual(true)
          } else {
            expect(await wallet.hasPassphraseSet()).toEqual(false)
          }
        })
      }
    )

    const importScenarios = [
      { mnemonic },
      { mnemonic, passphrase: 'abracadabra' },
      { mnemonic, locked: true },
      { mnemonic, locked: true, passphrase: 'abracadabra' },
    ]

    describe.each(importScenarios)(
      'wallet.import($mnemonic)',
      ({ mnemonic, passphrase, locked }) => {
        it('wallet is valid after wallet.import() ', async () => {
          const seedId = await getSeedId(await mnemonicToSeed({ mnemonic }))

          if (locked) await wallet.lock()
          await wallet.import({ mnemonic, passphrase })

          expect(await wallet.exists()).toEqual(true)
          expect(await wallet.getMnemonic({ passphrase })).toEqual(mnemonic)

          const metadata = await seedMetadataAtom.get()
          expect(metadata[seedId].dateCreated).toBe(now)
        })
      }
    )

    const itWithPassphrase = usePassword ? it : it.skip
    itWithPassphrase('lets you change the passphrase', async () => {
      const currentPassphrase = 'abc'
      const newPassphrase = '123'
      await wallet.create({ passphrase: currentPassphrase })
      await wallet.changePassphrase({ currentPassphrase, newPassphrase })
      const wallet1 = createWallet(walletOpts)
      await expect(wallet1.unlock({ passphrase: currentPassphrase })).rejects.toThrow(
        /wrong password/i
      )
      await expect(wallet1.unlock({ passphrase: newPassphrase })).resolves.not.toThrow()
    })

    describe('import', () => {
      it.each([
        [
          'invalid length',
          'cousin access oak tragic entire dynamic marine expand govern enjoy honey',
          new NamedError({ name: 'UnexpectedWordCount' }),
        ],
        [
          'invalid words',
          'cousin rudolf peter jÃ¼rgen entire dynamic marine expand govern enjoy honey tissue',
          new NamedError({ name: 'InvalidPhrase' }),
        ],
        ['invalid type', mnemonic.split(' '), /the secret phrase provided is not a string/i],
      ])('should throw when mnemonic has %s', async (_, mnemonic, error) => {
        await expect(wallet.import({ mnemonic })).rejects.toThrow(error)
      })

      it('supports more mnemonic lengths when configured to', async () => {
        const mnemonic = await generateMnemonic({ bitsize: 256 }) // 256 = 24 words

        const wallet = createWallet({
          ...walletOpts,
          config: { maxExtraSeeds, useAutoGeneratedPassword, validMnemonicLengths: [12, 24] },
        })

        await expect(wallet.import({ mnemonic })).resolves.not.toThrow()
      })
    })

    describe('primarySeedIdAtom', async () => {
      const seedId = await getSeedId(await mnemonicToSeed({ mnemonic }))
      it('sets primarySeedIdAtom on unlock', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await expect(primarySeedIdAtom.get()).resolves.toEqual(seedId)
      })

      it('primarySeedIdAtom.get works while locked', async () => {
        await wallet.import({ mnemonic })
        await wallet.unlock()
        await wallet.lock()
        await expect(primarySeedIdAtom.get()).resolves.toEqual(seedId)
      })
    })

    if (maxExtraSeeds === 0) {
      describe('single-seed mode', () => {
        it('does not export extra seeds passphrase', async () => {
          const exportKeySpy = jest.spyOn(keychain, 'exportKey')
          await wallet.create()
          await wallet.unlock()
          expect(exportKeySpy).not.toHaveBeenCalled()
        })

        it('throws on addSeed', async () => {
          await wallet.create()
          await wallet.unlock()

          await expect(
            wallet.addSeed({
              mnemonic: otherMnemonic,
              label: 'Metamask Savings',
              compatibilityMode: 'phantom',
            })
          ).rejects.toThrow(/Maximum/)
        })
      })
    } else {
      describe('multiple seeds', () => {
        const ethereumKeyId = new KeyIdentifier({
          asset: 'ethereum',
          derivationAlgorithm: 'BIP32',
          derivationPath: `m/44'/60'/0'/0/0`,
        })

        describe('addSeed', () => {
          it('stores keys in keychain', async () => {
            await wallet.create()
            await wallet.unlock()

            const seedId = await wallet.addSeed({
              mnemonic: otherMnemonic,
              label: 'Metamask Savings',
              compatibilityMode: 'phantom',
            })

            const { publicKey, privateKey } = await keychain.exportKey({
              seedId,
              keyId: ethereumKeyId,
              exportPrivate: true,
            })

            expect(publicKey).toEqual(
              Buffer.from(
                '020c8da08ca8ef147ea64323e539d791013ff0db4ae9d31c93e29482189af70de5',
                'hex'
              )
            )

            expect(privateKey).toEqual(
              Buffer.from('bb42809079e6564ec7e45af4d6a8fb8c5edc9373d8585b86f62f46ec7aa41729', 'hex')
            )
          })
        })

        it('sets seeds metadata', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
            compatibilityMode: 'phantom',
          })

          await expect(seedMetadataAtom.get()).resolves.toMatchObject({
            [seedId]: {
              label: 'Metamask Savings',
              dateCreated: now,
            },
          })
        })

        it('stores data in wallet storage', async () => {
          const seedStorage = createUnencryptedSeedStorage()
          const wallet = createWallet({ ...walletOpts, seedStorage })

          await wallet.create()
          await wallet.unlock()

          await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
            compatibilityMode: 'phantom',
          })

          const extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
          expect(extraSeeds.length).toBe(1)

          const [seed] = extraSeeds
          expect(seed).toMatchObject({
            mnemonic: otherMnemonic,
            compatibilityMode: 'phantom',
          })

          expect(Buffer.isBuffer(seed.seed)).toBe(true)
          expect(seed.dateCreated).toBe(now)
        })

        it('removes a single seed', async () => {
          const seedStorage = createUnencryptedSeedStorage()
          const wallet = createWallet({ ...walletOpts, seedStorage })
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
          })
          const otherSeedId = await wallet.addSeed({ mnemonic: 'menu '.repeat(12).trim() })
          let extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
          expect(extraSeeds.length).toBe(2)

          const keys = await Promise.all(
            [seedId, otherSeedId].map((id) => {
              return keychain.exportKey({
                seedId: id,
                keyId: ethereumKeyId,
              })
            })
          )

          keys.forEach((key) => {
            expect(key).toBeDefined()
          })

          await wallet.removeSeed(seedId)
          extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
          expect(extraSeeds.length).toBe(1)

          extraSeeds.forEach((seed) => {
            expect(seed && typeof seed === 'object').toBe(true)
            expect(seed.mnemonic).toMatch(/^(\b\w+\b\s+){11}\b\w+\b$/) // 12 words
            expect(typeof seed.dateCreated).toBe('number')
            expect(Buffer.isBuffer(seed.seed)).toBe(true)
          })

          await expect(() =>
            keychain.exportKey({
              seedId,
              keyId: ethereumKeyId,
            })
          ).rejects.toThrow(`seed with id "${seedId}" is not initialized`)

          await wallet.lock()
          await wallet.unlock()

          await expect(() =>
            keychain.exportKey({
              seedId,
              keyId: ethereumKeyId,
            })
          ).rejects.toThrow(`seed with id "${seedId}" is not initialized`)

          extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
          expect(extraSeeds.length).toBe(1)
        })

        it('does not throw when removing a single seed (encrypted seed storage)', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
          })
          await expect(wallet.removeSeed(seedId)).resolves.not.toThrow()
        })

        it('removes multiple seeds at once', async () => {
          const seedStorage = createUnencryptedSeedStorage()
          const wallet = createWallet({
            ...walletOpts,
            seedStorage,
            config: { maxExtraSeeds: 5, useAutoGeneratedPassword, validMnemonicLengths: [12] },
          })
          await wallet.create()
          await wallet.unlock()

          const seedId01 = await wallet.addSeed({ mnemonic: otherMnemonic })
          const seedId02 = await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })
          const seedId03 = await wallet.addSeed({ mnemonic: 'abandon '.repeat(12).trim() })

          const keys = await Promise.all(
            [seedId01, seedId02, seedId03].map((id) => {
              return keychain.exportKey({
                seedId: id,
                keyId: ethereumKeyId,
                exportPrivate: true,
              })
            })
          )

          keys.forEach((key) => {
            expect(key).toBeDefined()
          })

          let extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
          expect(extraSeeds.length).toBe(3)

          const removedSeedIds = [seedId01, seedId02]
          await wallet.removeManySeeds(removedSeedIds)
          extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
          expect(extraSeeds.length).toBe(1)

          extraSeeds.forEach((seed) => {
            expect(seed && typeof seed === 'object').toBe(true)
            expect(seed.mnemonic).toMatch(/^(\b\w+\b\s+){11}\b\w+\b$/) // 12 words
            expect(typeof seed.dateCreated).toBe('number')
            expect(Buffer.isBuffer(seed.seed)).toBe(true)
          })

          await Promise.allSettled(
            removedSeedIds.map(async (seedId) => {
              await expect(() =>
                keychain.exportKey({
                  seedId,
                  keyId: ethereumKeyId,
                })
              ).rejects.toThrow(`seed with id "${seedId}" is not initialized`)
            })
          )

          await wallet.create()
          await wallet.unlock()

          await Promise.allSettled(
            removedSeedIds.map(async (seedId) => {
              await expect(() =>
                keychain.exportKey({
                  seedId,
                  keyId: ethereumKeyId,
                })
              ).rejects.toThrow(`seed with id "${seedId}" is not initialized`)
            })
          )

          const remainingSeed = await keychain.exportKey({
            seedId: seedId03,
            keyId: ethereumKeyId,
            exportPrivate: true,
          })

          expect(remainingSeed).toEqual(keys[2])
        })

        it('does not throw when removing multiple seeds at once (encrypted seed storage)', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId01 = await wallet.addSeed({ mnemonic: otherMnemonic })
          const seedId02 = await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })

          await expect(wallet.removeManySeeds([seedId01, seedId02])).resolves.not.toThrow()
        })

        it('fetches extraSeedIds', async () => {
          await wallet.create()
          await wallet.unlock()

          await expect(wallet.getExtraSeedIds()).resolves.toEqual([])

          const seedId01 = await wallet.addSeed({ mnemonic: otherMnemonic })
          const seedId02 = await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })

          await expect(wallet.getExtraSeedIds()).resolves.toEqual([seedId01, seedId02])
        })

        it('removes seeds metadata', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
          })

          await wallet.removeSeed(seedId)
          const metadata = await seedMetadataAtom.get()
          expect(metadata).not.toHaveProperty(seedId)
        })

        it('does not remove primary seed', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await primarySeedIdAtom.get()
          await expect(wallet.removeSeed(seedId)).rejects.toThrow('Cannot remove primary seed')
        })

        it('does not allow removing seeds with wallet locked', async () => {
          await wallet.create()
          await expect(wallet.removeSeed('test')).rejects.toThrow('locked')
        })

        it('can update seed metadata', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
          })

          const dateCreated = now
          now = Date.now()

          await wallet.updateSeed({ seedId, label: "Bruce Wayne's Savings" })

          await expect(seedMetadataAtom.get()).resolves.toMatchObject({
            [seedId]: {
              label: "Bruce Wayne's Savings",
              dateCreated,
              dateUpdated: now,
            },
          })
        })

        it('updating seed does not allow overriding dateCreated', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({
            mnemonic: otherMnemonic,
            label: 'Metamask Savings',
          })

          await wallet.updateSeed({
            seedId,
            label: 'ABC',
            dateCreated: new Date(2022, 0, 20).getTime(),
          })

          await expect(seedMetadataAtom.get()).resolves.toMatchObject({
            [seedId]: { label: 'ABC', dateCreated: now },
          })
        })

        it('extra seeds survive lock + unlock', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })
          await wallet.lock()
          await wallet.unlock()

          const { publicKey } = await keychain.exportKey({
            seedId,
            keyId: ethereumKeyId,
          })

          expect(publicKey).toEqual(
            Buffer.from('020c8da08ca8ef147ea64323e539d791013ff0db4ae9d31c93e29482189af70de5', 'hex')
          )
        })

        it('getMnemonic() can get extra seeds', async () => {
          await wallet.create()
          await wallet.unlock()

          const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })

          const mnemonic = await wallet.getMnemonic({ seedId })
          await expect(mnemonicIsInvalid({ mnemonic })).resolves.toBe(false)
          expect(otherMnemonic === mnemonic).toBeTruthy()
        })

        it('getMnemonic() throws for extra seeds if passphrase incorrect', async () => {
          const passphrase = '123456'
          await wallet.create({ passphrase })
          await wallet.unlock({ passphrase })

          const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })

          await expect(() => wallet.getMnemonic({ seedId })).rejects.toThrow(
            'Wrong password. Try again.'
          )
        })

        it('getMnemonic() can get extra seeds if passphrase correct', async () => {
          const passphrase = '123456'
          await wallet.create({ passphrase })
          await wallet.unlock({ passphrase })

          const seedId = await wallet.addSeed({ mnemonic: otherMnemonic })

          const mnemonic = await wallet.getMnemonic({ seedId, passphrase })
          await expect(mnemonicIsInvalid({ mnemonic })).resolves.toBe(false)
          expect(otherMnemonic === mnemonic).toBeTruthy()
        })

        it('getMnemonic() throws for extra seeds if seedId not found', async () => {
          await wallet.create()
          await wallet.unlock()

          await wallet.addSeed({ mnemonic: otherMnemonic })

          await expect(() => wallet.getMnemonic({ seedId: 'random' })).rejects.toThrow(
            'No seed matches seedId.'
          )
        })
      })

      describe('addSeed', () => {
        it('throws if wallet is locked', async () => {
          await wallet.import({ mnemonic })
          await wallet.lock()
          await expect(wallet.addSeed({ mnemonic: otherMnemonic })).rejects.toThrow(/locked/)
        })

        it('throws is primary seed is re-added as extra seed', async () => {
          await wallet.import({ mnemonic })
          await wallet.unlock()
          await expect(wallet.addSeed({ mnemonic })).rejects.toThrow(/already present/)
        })

        it('allows to add an extra seed', async () => {
          await wallet.import({ mnemonic })
          await wallet.unlock()
          keychain.addSeed = jest.fn(keychain.addSeed)
          await expect(wallet.addSeed({ mnemonic: otherMnemonic })).resolves.not.toThrow()
          expect(keychain.addSeed).toHaveBeenCalledWith(otherSeed)
        })

        it('throws if same extra seed added twice', async () => {
          await wallet.import({ mnemonic })
          await wallet.unlock()
          await expect(wallet.addSeed({ mnemonic: otherMnemonic })).resolves.not.toThrow()
          await expect(wallet.addSeed({ mnemonic: otherMnemonic })).rejects.toThrow(
            /already present/
          )
        })

        it('loads extra seed on unlock', async () => {
          await wallet.import({ mnemonic })
          await wallet.unlock()
          await wallet.addSeed({ mnemonic: otherMnemonic })
          await wallet.lock()
          keychain.addSeed = jest.fn(keychain.addSeed)
          await wallet.unlock()
          expect(keychain.addSeed).toHaveBeenCalledWith(seed)
          expect(keychain.addSeed).toHaveBeenCalledWith(otherSeed)
        })

        it('clears extra seeds on clear()', async () => {
          seedMetadataAtom.set = jest.fn(seedMetadataAtom.set)

          await wallet.import({ mnemonic })
          await wallet.unlock()
          await wallet.addSeed({ mnemonic: otherMnemonic })
          await wallet.clear()
          await wallet.import({ mnemonic })
          keychain.addSeed = jest.fn(keychain.addSeed)
          await wallet.unlock()
          expect(keychain.addSeed).toHaveBeenCalledWith(seed)
          expect(keychain.addSeed).not.toHaveBeenCalledWith(otherSeed)
          expect(seedMetadataAtom.set).toHaveBeenCalledWith(undefined)
        })

        it('allows adding seeds up to the configured cap (maxExtraSeeds)', async () => {
          const seedStorage = createUnencryptedSeedStorage()
          const wallet = createWallet({ ...walletOpts, seedStorage })
          await wallet.import({ mnemonic })
          await wallet.unlock()
          await wallet.addSeed({ mnemonic: otherMnemonic })
          await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })

          const extraSeeds = await seedStorage.namespace('wallet').get('extraSeeds')
          expect(extraSeeds.length).toBe(2)
        })

        it('caps max seeds at configured value', async () => {
          await wallet.import({ mnemonic })
          await wallet.unlock()
          await wallet.addSeed({ mnemonic: otherMnemonic })
          await wallet.addSeed({ mnemonic: 'menu '.repeat(12) })
          await expect(wallet.addSeed({ mnemonic: 'abandon '.repeat(12).trim() })).rejects.toThrow(
            /Maximum/
          )
        })
      })
    }
  }
)
